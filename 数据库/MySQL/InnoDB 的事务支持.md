# 事务的基本概念
事务的基本属性：原子性、一致性、隔离性、持久性

常见的事务四种隔离级别，分别是未提交读，提交读，可重复读，串行化，这四种隔离级别可能会出现的问题如下
| 隔离级别 | 脏读 | 不可重复读 | 幻读 |

|隔离级别|  脏读 |   不可重复读 | 幻读 |
|:-----| :--------:| :------: | :----:|
| 未提交读 RU | √ | √ | √ |
| 提交读 RC |  ×  | √  | √ |
|可重复读 RR| ×  | × | √ |
|串行化     | ×  | × | × |

默认情况下，MySQL 的隔离级别是 RR 级别，其通过 next-key lock 与 mvcc 已经解决了该种隔离级别下可能会出现幻读的问题，但在某种特别的场景下，有可能会触发。

## InnoDB 如何保证事务的正确性
在 innoDB 中，事务的准确性是由 redo log 和 undo log 共同作用保证的，这两个日志文件存储的是页面数据。

在一个事务中，当一条写操作 SQL 执行时，并不是直接修改磁盘的数据，而是将先将更新后的页面数据写到 redo log 中，此条数据的 status 为 prepare 状态，同时将更新前的数据页面保存在 undo log 中，在 undo log 有一个回滚段的结构，它用来保存对应页面的回滚数据链

当事务提交时，会将 redo log 中数据进行 commit，status 从 prepare 状态变为 commit，此时数据才算真正提交（二阶段提交）；

当事务进行回滚时，会从 undo log 中，遍历回滚段链表，找到当前事务 id 修改前页面数据进行回滚。

关于 redo log、undo log 的机制请查看 [redo log、undo log](xxx)

## 快照读与当前读
InnoDB 有两种读取模式，分别是快照读和当前读，快照读基于 MVCC 实现，当前读则使用 lock 来实现

### MVCC 快照读
在 innoDB 中，每条记录默认有两种字段
- 事务 id：标识当前记录由哪个事务创建
- roll pointed：指向上一个回滚段

一个记录是否对当前事务可见，依赖以下两个机制
- 当前事务的修改默认对当前事务可见
- read view 可读视图

**可读视图**
可读视图是指查询时生成的一个快照数据，对于每一行记录它有几个核心属性
- LOW_TX_ID：当前快照中记录最高的 TX_ID
- UP_TX_ID：当前快照中记录最低的 TX_ID
- active_tx_group：当前活跃的事务数组

记录是否可见，由以下机制决定
1. 如果 TX_ID > LOW_TX_ID，则记录不可见
2. 如果 TX_ID < UP_TX_ID，则记录可见
3. 如果 TX_ID 落于 [UP_TX_ID, LOW_TX_ID]，则判断当前 TX_ID 是否在活跃事务数组内，如果不存在，则可见；如果存在，则当前记录不可见，通过 roll pointer 向上查找回滚段，再根据同样的机制判断是否可见

**不可重复读**
RR 级别不会出现不可重复读问题，而 RC 级别则会出现，主要原因是因为 RR 级别下 read view 是在事务开启后第一次 select 查询时生成，且在事务未结束前，都不会重新产生 read view；而 RC 级别下，每一个 select 执行时，都会触发产生新的 read view，因此在多次读时可以看到事务期间已经提交了的事务的数据。

### 快照读
使用 select for update、select lock in shard mode 或者更新语句，innoDB 会为记录加上锁。
加锁的机制
1. 当命中唯一索引时且非范围查询，则只对索引项加行锁
2. 当命中非唯一索引或范围查询，则会加上行锁+gap锁，锁住间隙，从而避免出现幻读的问题